// Add作る。
// mousePressedされるとその位置に対応したスタートが記録される
// 振動数も記録されて新しいノートが入るのは確定する
// mouseIsPressedで仮のスタート位置がundefinedでない限り、常に編集中のTrackを調べて、被ってるものがあったら排除して、
// 最終的な位置を決定する必要があるわけ。
// デフォルトは4の倍数でしか変えられないけど1/2と1/4のモードに切り替えられるようにする。
// とはいえ面倒なので、クリックしたら・・たとえば2番目だったら新しいNoteArrayはまず2つまで放り込んで、その時点で消えてるから、
// ごめんinsertあったわ。配列aに対してa.splice(i, -1, x)ってやるとi番目がxで置き換えられるみたい。（iは0ベース）
// この場合は何か値を指定しないとエラーになるので注意！ちなみにnoteArray本体が空っぽでも使えるし末尾に追加するのもこれでOKみたい。だから
// 追加場所だけ分かればいい。排除についてはsplice(y, 1)でOK.

// まとめると、まず追加時のインデックスはクリックしたときにもう決まってしまう。で、
// ああ、どれかのNoteとかぶるならそれを排除したうえでそれのインデックス、そうでないなら間、つまり、
// 間っていうのはインターバルの最小単位が1とか2とか4でそれに基づいてっていう意味。その範囲が
// 被るものをすべて排除し、それが存在する最小のインデックスが追加時のインデックスで確定。
// サーチは末尾から行う。
// 2段階に分けます・・
// 初めにrightが範囲のleft以下のNoteがいくつあるか調べて、その個数が追加するときのインデックスになります。
// 次に末尾からサーチしていってかぶってるものをすべて排除します。(Aのright<=BのleftまたはBのright<=Aのleftの否定。つまりBのleft<AのrightかつAのleft<Bのright)
// 末尾からでないと失敗する。
// 次にマウスが動いている間範囲を常に計算、これは末尾が最小単位に応じて変化します。startとsustainの数字。1か2か4の倍数。
// タイルも一時的に描画されます。
// その間毎フレーム被ってるかどうか調べられて末尾からサーチで被ってたら排除、を繰り返す。
// 範囲は右にしか伸びないので後ろのは消されない。ややこしくなるのでこれで。めんどくさい。とりあえず動くものを作ろう。

// 即時関数ってここに書くのね（遊んでる場合か）
